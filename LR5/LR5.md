# Лабораторная работа №5

Задача: 
-

Сравните время работы двух реализаций функции вычисления факториала:

- рекурсивной,

- нерекурсивной (через цикл).

Изучить материал про мемоизацию и реализовать сравнение мемоизованных и немемоизованных вариантов функций (рекурсивной и нерекурсивной. Проанализировать результаты и сделать выводы, описать выводы в отчете, построить графики.

Для сравнения используйте модуль timeit, а для наглядности постройте график с помощью matplotlib, показывающий зависимость времени выполнения от входных данных.


Условия:

Реализуйте две функции `fact_recursive(n)` и `fact_iterative(n)`.

Для корректного сравнения используйте одинаковый набор чисел для тестирования.

Визуализируйте результаты (`ось X` — размер входного числа `n`, `ось Y` — время вычислений).

Сравните эффективность двух подходов.

Требования: 

- сгенерировать один фиксированный список чисел для всех прогонов и несколько раз запустить вычисления для усреднения.

- необходимо провести "чистый бенчмарк" одного вызова (для одного числа) / показать replit. 


Описание действий при выполнении:
-

Данный код проводит честное сравнение производительности двух реализаций вычисления факториала — рекурсивной и итеративной — с помощью «чистого бенчмарка одного вызова». 

Для этого используется модуль `timeit` с параметром `number=1`, что гарантирует измерение времени выполнения ровно одного вызова функции, а не усреднённого времени множества вызовов.

Бенчмарк повторяется 7 раз для каждого значения `n`, и в расчёт берётся минимальное время — стандартная практика для минимизации влияния системного «шума». 

Тестирование выполняется на фиксированном детерминированном наборе входных данных: `n = 10, 20, 30, ..., 300`. 

Результаты визуализируются с помощью `matplotlib`: по `оси X` отложено значение `n`, по `оси Y` — время выполнения в секундах (график можно легко адаптировать к миллисекундам при выводе). 

Код не использует случайные числа, обеспечивая полную воспроизводимость эксперимента, и демонстрирует, что итеративная реализация стабильно быстрее рекурсивной из-за отсутствия накладных расходов на вызовы функций.
